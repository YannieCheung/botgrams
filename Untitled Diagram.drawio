<mxfile host="app.diagrams.net" modified="2022-12-19T16:44:18.753Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.46" version="20.7.2" etag="nAOkXM6fAQ8KAUS16aWN" type="github">
  <diagram id="uc2dsn9P-SxqrpjeY-UU" name="Page-1">
    <mxGraphModel dx="1369" dy="920" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="nfsQdx0FcawMK_jn6A5h-1" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="120" y="210" width="530" height="760" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-2" value="数据抽象&lt;br&gt;算平均价的函数不是接口，不公开给类的用户&lt;br&gt;&lt;br&gt;通过访问修饰符加强类的封装 性&lt;br&gt;public 不变&lt;br&gt;private 实现细节 可以变&lt;br&gt;那么用户就不需要变" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="50" y="170" width="230" height="140" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-3" value="常量成员函数" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="130" y="320" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-4" value="成员函数隐式inline" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="490" y="220" width="150" height="40" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-5" value="内声明，内外定义" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="490" y="270" width="150" height="40" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-6" value="模拟复合运算符+=" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#fff2cc;strokeColor=#d6b656;" vertex="1" parent="1">
          <mxGeometry x="130" y="420" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-7" value="非成员函数如果是类的接口&lt;br&gt;因此他们与类声明在同一个头文件中" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="490" y="320" width="150" height="40" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-8" value="IO对象只能引用，不能复制&lt;br&gt;IO对象会修改，不能是底层const" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="220" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-9" value="&lt;br&gt;默认构造函数在以下两种情况下的行为：&lt;br&gt;1、有类内初始值&lt;br&gt;2、没有..(进行默认初始化）&lt;br&gt;默认初始化不一定都有效" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="320" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-10" value="拷贝、复制和析构&lt;br&gt;没有定义时，编译器提供合成的默认版本&lt;br&gt;&lt;br&gt;堆上的数据拷贝不能依赖于编译器合成的版本&lt;br&gt;可以依赖vector和string" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="420" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-12" value="右值：取不到地址的表达式&lt;br&gt;如5；&amp;amp;a (&amp;amp; &amp;amp;a对地址取地址)&lt;br&gt;左值：能取到地址的表达式&lt;br&gt;a;&lt;br&gt;- 1常量对象为代表的左值不能作为赋值语句的左侧运算对象&lt;br&gt;const int a = 3;&lt;br&gt;a=4;&lt;br&gt;-2某些表达式的求值结果是对象，但他们是右值&lt;br&gt;如 a + 1 它返回临时对象，就没办法取到这个临时对象的地址&lt;br&gt;&lt;br&gt;3当一个对象被当作右值的时候，用得是对象的值（内存中的内容）&lt;br&gt;4当一个对象被当作左值的时候，用得是对象的身份（内存中的位置）&lt;br&gt;&lt;br&gt;5左值可以当成右值，实际使用的是它的内容（值）&lt;br&gt;6不能把右值当成左值 （没有地址，没办法往里面放东西）&lt;br&gt;&lt;br&gt;7取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。（区分指针变量和临时指针对象&lt;br&gt;）&lt;br&gt;(&amp;amp;a) 为一个指向a的指针，不能对它取地址，所以（&amp;amp;a）是右值&lt;br&gt;而 int *p = &amp;amp;a&amp;nbsp; ，可以对P取地址，所以p是个左值&lt;br&gt;8 如果表达式的求值结果是左值 decltype作用于该表达式（不是变量）的到一个引用类型 int *p&lt;br&gt;decltype(*p) - int&amp;amp;&amp;nbsp; 解引用得到一个指针指向的”对象” 即是左值 那就得到引用类型&lt;br&gt;decltype(&amp;amp;p) &amp;amp;p为一个右值，结果就是int** 指向指针的指针&lt;br&gt;&lt;br&gt;算术运算符的运算对象和求值结果都是右值&lt;br&gt;赋值运算符的左侧运算对象是一个左值" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="220" y="990" width="550" height="380" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-16" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" source="nfsQdx0FcawMK_jn6A5h-13" target="nfsQdx0FcawMK_jn6A5h-2">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="50" y="605" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-13" value="在类中定义类型名称&lt;br&gt;（有访问限制）&lt;br&gt;&lt;br&gt;Screen的用户不需要知道Screen使用了一个string对象来存放它的数据，pos隐藏了细节，以后string可以被改变，用其他对象存放数据" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="130" y="560" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-14" value="可变数据成员&lt;br&gt;mutable&lt;br&gt;使常量对象的数据改动需求得以实现" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="530" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-15" value="成员函数返回引用，使用链式调用&lt;br&gt;1、如果返回的是对象，原先对象就被丢失了，链式调用会在新对象上操作&lt;br&gt;2、当静态成员函数返回对象引用时，因为对象是常量的，所以在使用链式调用时不能修改其值" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="650" width="150" height="140" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-17" value="常量成员函数与普通函数可以形成重载&lt;br&gt;&lt;br&gt;测试重载调用（见代码）" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="130" y="675" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-18" value="向前声明的类，在定义前是个不完整的类型&lt;br&gt;&lt;br&gt;不完整类型不能创建对象，但可以定义指向该类型的指针和引用（不能操作），或作为函数参数类型或返回值类型" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="130" y="790" width="150" height="110" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-19" value="类与类的友元关系&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;成员函数为友元的步骤很重要，使用它需要修改很多结构。&lt;br&gt;&lt;/font&gt;&lt;br&gt;重载函数是不同的函数" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="290" y="810" width="150" height="90" as="geometry" />
        </mxCell>
        <mxCell id="nfsQdx0FcawMK_jn6A5h-20" value="类的作用域&lt;br&gt;返回类型不在作用域内&lt;br&gt;&lt;br&gt;名字查找：&lt;br&gt;1、先内部查找（使用名字之前的位置），找不到到内外再找&lt;br&gt;&lt;font color=&quot;#ff3333&quot;&gt;这里会有个重复定义的问题&lt;/font&gt;&lt;br&gt;&lt;br&gt;2、成员函数定义中的名字查找&lt;br&gt;内-&amp;gt;中-&amp;gt;全局作用域&lt;br&gt;例子username" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="480" y="810" width="150" height="100" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
